(define (mrlist num)
  (if (<= num 0)
      '()
      (cons num (mrlist (- num 1)))))

(define (mlist num)
  (let ((x (mrlist num)))
    (reverse x)))

(define family
 '(a (b1 (c1 (d1 (e1)
                 (e2))
             (d2 (e3)
                 (e4)))
         (c2 (d3 (e5)
                 (e6))
             (d4 (e7)
                 (e8)))
         (c2a(d4a(e8a)
                 (e8b)
                 (e8c))
             (d4b(e8d)
                 (e8e)
                 (e8f))
             (d4c)))
     (b2 (c3 (d5 (e9)
                 (e10))
             (d6 (e11)
                 (e12)))
         (c4 (d7 (e13)
                 (e14))
             (d8 (e15)
                 (e16))))
     (b3 (c5 (d9 (e17)
                 (e18))
             (d10(e19)
                 (e20)))
         (c6 (d11(e21)
                 (e22))
             (d12(e23)
                 (e24))))))
(define family2
  '(a (b1)
      (b2 (c1)
          (c2))
      (b3)))

(define (sons tree) ;treeのトップの子要素のリストを返す
  (map car (cdr tree)))
(define (subtree num tree) ;treeのnum番目のサブツリーを返す
  (if (> num (length (cdr tree))) ;treeの子要素数がnumよりも少ない場合は
      #f                          ;#fを返す
      (let loop ((i num)(t tree))
        (if (< 1 i)
            (loop (- i 1)(cdr t))
            (car (cdr t))))))
(define (nos tree) ;the Number Of Sons
  (length (sons tree)))
(define (make-grandsons-tree tree)
  (let ((result (list (car tree))))
    (let loop ((i 1))
      (if (<= i (nos tree))
          (begin (set! result (append result (cdr (subtree i tree))))
                 (loop (+ i 1)))
          #f))
    result))
(define result1 (sons family))
(define result2 '())
(set! result2 (append result2 (sons (subtree 1 family))))
(set! result2 (append result2 (sons (subtree 2 family))))
(set! result2 (append result2 (sons (subtree 3 family))))

(define result3 '())
(set! result3 (append result3 (sons (subtree 1 (subtree 1 family)))))
(set! result3 (append result3 (sons (subtree 2 (subtree 1 family)))))
(set! result3 (append result3 (sons (subtree 3 (subtree 1 family)))))
(set! result3 (append result3 (sons (subtree 1 (subtree 2 family)))))
(set! result3 (append result3 (sons (subtree 2 (subtree 2 family)))))
(set! result3 (append result3 (sons (subtree 1 (subtree 3 family)))))
(set! result3 (append result3 (sons (subtree 2 (subtree 3 family)))))

(define result4 '())
(set! result4 (append result4 (sons (subtree 1 (subtree 1 (subtree 1 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 1 (subtree 1 family))))))
(set! result4 (append result4 (sons (subtree 1 (subtree 2 (subtree 1 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 2 (subtree 1 family))))))
(set! result4 (append result4 (sons (subtree 1 (subtree 3 (subtree 1 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 3 (subtree 1 family))))))
(set! result4 (append result4 (sons (subtree 3 (subtree 3 (subtree 1 family))))));この文はなくても良い
(set! result4 (append result4 (sons (subtree 1 (subtree 1 (subtree 2 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 1 (subtree 2 family))))))
(set! result4 (append result4 (sons (subtree 1 (subtree 2 (subtree 2 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 2 (subtree 2 family))))))
(set! result4 (append result4 (sons (subtree 1 (subtree 1 (subtree 3 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 1 (subtree 3 family))))))
(set! result4 (append result4 (sons (subtree 1 (subtree 2 (subtree 3 family))))))
(set! result4 (append result4 (sons (subtree 2 (subtree 2 (subtree 3 family))))))



(define (get-depth tree depth)
  (let ((result '()))
    (cond ((<= depth 0)(set! result (list (car tree))))
          ((= depth 1)(set! result (append result (sons tree))))
          ((= depth 2) ;depth >= 2の時
           (let loop ((t tree)(i 1))
             (if (<= i (nos t))
                 (begin (set! result (append result (sons (subtree i t))))
                        (loop t (+ i 1)))
                 #f)))
          (else (set! result (append result (get-depth (make-grandsons-tree tree) (- depth 1))))))
    result))